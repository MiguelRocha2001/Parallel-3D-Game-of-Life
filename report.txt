In our solution, the main paralelization part was the loop in the count_species_and_simulate() function, that iterates over all cells, and computes the next value for that same cell. This function, while iterating through all cells, it counts the number of species, for the current generation.
To solve the first task, we had two options:
    - Paralelize the three for loops with a colapse directive;
    - Paralelize the outer loop only.

First, all outer loop iterations have the same amount of work, since all they will execute another two for loops with the same number of iterations, and each inner loop iteration will compute the next value of that cell, which is the same amount of work for all cells/iterations. This is because, when computing the next value of a cell, it envolves looping for the same amount of neighbours, which is always a constant value: 26.

Therefore, there is not such problem of load balancing. Having this in mind, there is no reason to use the colapse option. Actually, with the colapse option, each thread would not be garantueed to execute consecutive iterations of the outer loop, and thus, causing possible cache misses.

Tests were made for both possibilities and, having a better performance with the second one, with bigger speedups as the board grows.

Consequently, we used the second option, since this garantees that threads execute at least a chunk of consequtive outer loop itarations, not causing the cache miss overhead.

To solve the second task, counting the number of species, we used a reduction to avoid race issues. Usually, care must be taken when using this directive, since the piece of data will be copied for every thread in the loop, and, therefore, we used just an array of nine elements (number of available species).

Regarding the computation of the new cell value, done throught the get_neighbours() function, we opted to not add any paralelization, since the computation envolves small loops, that dont grow with the board length: iterating over the neighbours (26), and counting the most common neighbour specie (iterating over 9 possible species). This wouldnt justify having the overhead of creating more threads to paralelize this task.

Another point of paralelization is the apply_grid_updates() where we paralelized only the outer loop, instead of using a colapse directive, for the reasons described above.

Finally, we used also paralelization in other tasks, such as the grid initialization, and it's destruction. However, this doenst have much importance, since this taks are executed only once, and shouldn't cause much overhead.